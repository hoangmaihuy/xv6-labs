# Lab 1: System Calls 实习报告

| 姓名 | 学号 | 日期 |
| --- | --- | --- |
| 枚辉煌 | 1800094810 | 2021/03/21 |

- [Lab 1: System Calls 实习报告](#lab-1-system-calls-实习报告)
  - [1. 实验总结](#1-实验总结)
    - [Exercise 0: 源代码阅读](#exercise-0-源代码阅读)
    - [Exercise 1: System call tracing](#exercise-1-system-call-tracing)
    - [Exercise 2: Sysinfo](#exercise-2-sysinfo)
  - [2. 遇到的困难以及收获](#2-遇到的困难以及收获)
  - [3. 对课程或Lab的意见和建议](#3-对课程或lab的意见和建议)
  - [4. 参考文献](#4-参考文献)

## 1. 实验总结

### Exercise 0: 源代码阅读

Steps to add new system call:
- Declare new system call in `user/user.h`
- Define new system call number in `kernel/syscall.h`, defined name should starts with `SYS_`
- Add an `entry` in `user/usys.pl`. This Perl script will generate assembly code of a system call. Basically, it declares a function which puts syscall number defined in `kernel/syscall.h` to register `a7`, call `ecall` to trap system to kernel space then `ret` to return to caller function.
- Implement new syscall in `kernel/sysproc.c`
- Add new syscall's `syscalls` mapping in `kernel/syscall.c`

When user program does a syscall, for example `fork`, the following things happen:
- User program call user-level `fork` in `user/user.h`
- `fork` body is in `user/usys.S`, which is generated by `user/usys.pl` 
```
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
```
- `ecall` causes a trap, `usertrap()` in `kernel/trap.c` handle it and call `syscall()` in `kernel/syscall.c`
- `syscall()` takes syscall number in `a7`, get the function `sys_fork()` which is mapping with `SYS_fork` in `syscalls` and call it.
- `sys_fork()` do the job and return to `syscall()`
- `syscall()` returns to `usertrap()`, then `usertrap()` calls `usertrapret()` to make a transition to user space.

### Exercise 1: System call tracing
- Add `$U/_trace` to UPROGS in Makefile
- Declare `trace` in `user/user.h:27`
```c
int trace(int);
```
- Add trace's syscall number in `kernel/syscall.h:23`
```c
#define SYS_trace 22
```
- Add `trace` entry in `user/usys.pl:39`
```perl
entry("trace");
```

- Add `tmask` field in `struct proc` in `kernel/proc.h:96` to hold trace mask value.
```c
// kernel/proc.h
struct proc {
  ...
  int tmask;                // Trace mask used in trace syscall
}
```

- Implement `sys_trace` in `kernel/sysproc.c`, which reads the mask in 
register `a0` and save it to current process's `tmask`.

```c
uint64
sys_trace(void)
{
    int tmask;

    if (argint(0, &tmask) < 0)
        return -1;
    myproc()->tmask = tmask;
    return 0;
}
```

- Copy `tmask` when in `fork()` system call [`kernel/proc.c:283`] to copy trace mask from parent to child process
```c
// kernel/proc.c
void fork(void) {
  ...
  // copy trace mask
  np->tmask = p->tmask;
  ...
}
```

- Add `sys_trace` mapping in `kernel/syscall.c:132`
```c
// kernel/syscall.c
extern uint64 sys_trace(void);

static uint64 (*syscalls[])(void) = {
  ...
  [SYS_trace]   sys_trace,
}
```

- Add a syscall names mapping in `kernel/syscall:134`, which maps syscall number with its name 
```c
static char* syscall_names[] = {
  [SYS_fork]   = "fork",
  [SYS_exit]   = "exit",
  [SYS_wait]   = "wait",
  [SYS_pipe]   = "pipe",
  [SYS_read]   = "read",
  [SYS_kill]   = "kill",
  [SYS_exec]   = "exec",
  [SYS_fstat]  = "fstat",
  [SYS_chdir]  = "chdir",
  [SYS_dup]    = "dup",
  [SYS_getpid] = "getpid",
  [SYS_sbrk]   = "sbrk",
  [SYS_sleep]  = "sleep",
  [SYS_uptime] = "uptime",
  [SYS_open]   = "open",
  [SYS_write]  = "write",
  [SYS_mknod]  = "mknod",
  [SYS_unlink] = "unlink",
  [SYS_link]   = "link",
  [SYS_mkdir]  = "mkdir",
  [SYS_close]  = "close",
  [SYS_trace]  = "trace"
}
```
- Modify `syscall()` function in `kernel/syscall.c:171` to print trace output
```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    uint64 ret = syscalls[num]();
    p->trapframe->a0 = ret;
    // trace syscall
    int tmask = p->tmask;
    if (tmask & (1 << num))
      printf("%d: syscall %s -> %d\n", p->pid, syscall_names[num], ret);
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

### Exercise 2: Sysinfo
- Add $U/_sysinfotest to UPROGS in Makefile
- Repeat above steps to add `sysinfo` system call prototype.
```c
// user/user.h:28
struct sysinfo;
...
int sysinfo(struct sysinfo*);

// kernel/syscall.h:24
#define SYS_sysinfo 23

// user/usys.pl:40
entry("sysinfo");

// kernel/syscall.c
extern uint64 sys_info(void);

static uint64 (*syscalls[])(void) = {
  ...
  [SYS_sysinfo]   sys_sysinfo,
}

static char* syscall_names[] = {
  ...
  [SYS_sysinfo]= "sysinfo",
}
```
- Declare two helper functions `kcountfree()` and `countproc()` in `kernel/defs.h`
```c
// kalloc.c
...
uint64          kcountfree(void);

// proc.c
...
uint64          kcountfree(void);
```
- Implement `kcountfree()` in `kernel/kalloc.c`, which counts the length of `kmem.freelist`
then multiply by `PGSIZE`
```c
// Count free mem size
uint64
kcountfree(void)
{
  struct run *r;
  uint64 freemem = 0;

  acquire(&kmem.lock);
  for (r = kmem.freelist; r; r = r->next)
    freemem += PGSIZE;
  release(&kmem.lock);
  return freemem;
}
```
- Implement `countproc()` in `kernel/proc.c`, which iterates through process list 
and count the number of UNUSED process
```c
// Count number of processes
uint64
countproc(void)
{
  struct proc *p;
  uint64 nproc = 0;
  for (p = proc; p < &proc[NPROC]; p++)
  {
    acquire(&p->lock);
    if (p->state != UNUSED)
      nproc++;
    release(&p->lock);
  }
  return nproc;
}
```
- Implement `sys_sysinfo` in `kernel/sysproc.c`. `sys_sysinfo` read address 
of `struct sysinfo` in user space, declare new `struct sysinfo si` in kernel space, call
`kcountfree` and `countproc` then put infomation to `si`. Finally, it calls `copyout` to copy 
content from kernel space `si` to user space `addr`.
```c
uint64
sys_sysinfo(void)
{
  struct sysinfo si;
  struct proc *p = myproc();
  uint64 addr;
  // get user space address for sysinfo
  if (argaddr(0, &addr) < 0)
    return -1;

  si.freemem = kcountfree();
  si.nproc = countproc();

  if (copyout(p->pagetable, addr, (char*)&si, sizeof(si)) < 0)
    return -1;

  return 0;
}
```

## 2. 遇到的困难以及收获
Difficulties:
- Syscall's process is quite complicated
- When implementing `kcountfree` and `countproc`, I don't notice about concurrency 
problem at first and forget about acquire the lock before reading `kmem.freelist` and
process state `p->state`, which causes a few bugs.
- In the beginning, I don't really understand the use of `copyin` and `copyout` function, 
then I revised virtual memory and figured out.

Lessons:
- Understand a little bit more about syscall's process and trap handling
- Be more careful about concurrency in multiprogramming
## 3. 对课程或Lab的意见和建议
None
## 4. 参考文献
- [syscall lab hints on MIT website](https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html)
- Chapter 2, section 4.3 and 4.4 of chapter 4 of xv6 book.